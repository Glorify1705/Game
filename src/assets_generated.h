// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ASSETS_G_H_
#define FLATBUFFERS_GENERATED_ASSETS_G_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
                  FLATBUFFERS_VERSION_MINOR == 3 &&
                  FLATBUFFERS_VERSION_REVISION == 3,
              "Non-compatible flatbuffers version included");

namespace G {

struct ImageFile;
struct ImageFileBuilder;

struct Subtexture;
struct SubtextureBuilder;

struct SpritesheetFile;
struct SpritesheetFileBuilder;

struct ScriptFile;
struct ScriptFileBuilder;

struct SoundFile;
struct SoundFileBuilder;

struct AssetsPack;
struct AssetsPackBuilder;

enum class SoundType : uint8_t { OGG = 0, MIN = OGG, MAX = OGG };

inline const SoundType (&EnumValuesSoundType())[1] {
  static const SoundType values[] = {SoundType::OGG};
  return values;
}

inline const char *const *EnumNamesSoundType() {
  static const char *const names[2] = {"OGG", nullptr};
  return names;
}

inline const char *EnumNameSoundType(SoundType e) {
  if (::flatbuffers::IsOutRange(e, SoundType::OGG, SoundType::OGG)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSoundType()[index];
}

struct ImageFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageFileBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_WIDTH = 6,
    VT_HEIGHT = 8,
    VT_COMPONENTS = 10,
    VT_CONTENTS = 12
  };
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  uint32_t width() const { return GetField<uint32_t>(VT_WIDTH, 0); }
  uint32_t height() const { return GetField<uint32_t>(VT_HEIGHT, 0); }
  uint32_t components() const { return GetField<uint32_t>(VT_COMPONENTS, 0); }
  const ::flatbuffers::Vector<uint8_t> *contents() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENTS);
  }
  template <size_t Index>
  auto get_field() const {
    if constexpr (Index == 0)
      return filename();
    else if constexpr (Index == 1)
      return width();
    else if constexpr (Index == 2)
      return height();
    else if constexpr (Index == 3)
      return components();
    else if constexpr (Index == 4)
      return contents();
    else
      static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_COMPONENTS, 4) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyVector(contents()) && verifier.EndTable();
  }
};

struct ImageFileBuilder {
  typedef ImageFile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(ImageFile::VT_FILENAME, filename);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(ImageFile::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(ImageFile::VT_HEIGHT, height, 0);
  }
  void add_components(uint32_t components) {
    fbb_.AddElement<uint32_t>(ImageFile::VT_COMPONENTS, components, 0);
  }
  void add_contents(
      ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> contents) {
    fbb_.AddOffset(ImageFile::VT_CONTENTS, contents);
  }
  explicit ImageFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImageFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImageFile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImageFile> CreateImageFile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    uint32_t width = 0, uint32_t height = 0, uint32_t components = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> contents = 0) {
  ImageFileBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_components(components);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_filename(filename);
  return builder_.Finish();
}

struct ImageFile::Traits {
  using type = ImageFile;
  static auto constexpr Create = CreateImageFile;
  static constexpr auto name = "ImageFile";
  static constexpr auto fully_qualified_name = "G.ImageFile";
  static constexpr size_t fields_number = 5;
  static constexpr std::array<const char *, fields_number> field_names = {
      "filename", "width", "height", "components", "contents"};
  template <size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ImageFile> CreateImageFileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *filename = nullptr,
    uint32_t width = 0, uint32_t height = 0, uint32_t components = 0,
    const std::vector<uint8_t> *contents = nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto contents__ = contents ? _fbb.CreateVector<uint8_t>(*contents) : 0;
  return G::CreateImageFile(_fbb, filename__, width, height, components,
                            contents__);
}

struct Subtexture FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubtextureBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SPRITESHEET = 6,
    VT_X = 8,
    VT_Y = 10,
    VT_WIDTH = 12,
    VT_HEIGHT = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *spritesheet() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPRITESHEET);
  }
  uint32_t x() const { return GetField<uint32_t>(VT_X, 0); }
  uint32_t y() const { return GetField<uint32_t>(VT_Y, 0); }
  uint32_t width() const { return GetField<uint32_t>(VT_WIDTH, 0); }
  uint32_t height() const { return GetField<uint32_t>(VT_HEIGHT, 0); }
  template <size_t Index>
  auto get_field() const {
    if constexpr (Index == 0)
      return name();
    else if constexpr (Index == 1)
      return spritesheet();
    else if constexpr (Index == 2)
      return x();
    else if constexpr (Index == 3)
      return y();
    else if constexpr (Index == 4)
      return width();
    else if constexpr (Index == 5)
      return height();
    else
      static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SPRITESHEET) &&
           verifier.VerifyString(spritesheet()) &&
           VerifyField<uint32_t>(verifier, VT_X, 4) &&
           VerifyField<uint32_t>(verifier, VT_Y, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) && verifier.EndTable();
  }
};

struct SubtextureBuilder {
  typedef Subtexture Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Subtexture::VT_NAME, name);
  }
  void add_spritesheet(
      ::flatbuffers::Offset<::flatbuffers::String> spritesheet) {
    fbb_.AddOffset(Subtexture::VT_SPRITESHEET, spritesheet);
  }
  void add_x(uint32_t x) { fbb_.AddElement<uint32_t>(Subtexture::VT_X, x, 0); }
  void add_y(uint32_t y) { fbb_.AddElement<uint32_t>(Subtexture::VT_Y, y, 0); }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(Subtexture::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(Subtexture::VT_HEIGHT, height, 0);
  }
  explicit SubtextureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Subtexture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Subtexture>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Subtexture> CreateSubtexture(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> spritesheet = 0,
    uint32_t x = 0, uint32_t y = 0, uint32_t width = 0, uint32_t height = 0) {
  SubtextureBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_spritesheet(spritesheet);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Subtexture::Traits {
  using type = Subtexture;
  static auto constexpr Create = CreateSubtexture;
  static constexpr auto name = "Subtexture";
  static constexpr auto fully_qualified_name = "G.Subtexture";
  static constexpr size_t fields_number = 6;
  static constexpr std::array<const char *, fields_number> field_names = {
      "name", "spritesheet", "x", "y", "width", "height"};
  template <size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Subtexture> CreateSubtextureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *name = nullptr,
    const char *spritesheet = nullptr, uint32_t x = 0, uint32_t y = 0,
    uint32_t width = 0, uint32_t height = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto spritesheet__ = spritesheet ? _fbb.CreateString(spritesheet) : 0;
  return G::CreateSubtexture(_fbb, name__, spritesheet__, x, y, width, height);
}

struct SpritesheetFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpritesheetFileBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_IMAGE_NAME = 6,
    VT_SUB_TEXTURE = 8
  };
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  const ::flatbuffers::String *image_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMAGE_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<G::Subtexture>>
      *sub_texture() const {
    return GetPointer<
        const ::flatbuffers::Vector<::flatbuffers::Offset<G::Subtexture>> *>(
        VT_SUB_TEXTURE);
  }
  template <size_t Index>
  auto get_field() const {
    if constexpr (Index == 0)
      return filename();
    else if constexpr (Index == 1)
      return image_name();
    else if constexpr (Index == 2)
      return sub_texture();
    else
      static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyOffset(verifier, VT_IMAGE_NAME) &&
           verifier.VerifyString(image_name()) &&
           VerifyOffset(verifier, VT_SUB_TEXTURE) &&
           verifier.VerifyVector(sub_texture()) &&
           verifier.VerifyVectorOfTables(sub_texture()) && verifier.EndTable();
  }
};

struct SpritesheetFileBuilder {
  typedef SpritesheetFile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(SpritesheetFile::VT_FILENAME, filename);
  }
  void add_image_name(::flatbuffers::Offset<::flatbuffers::String> image_name) {
    fbb_.AddOffset(SpritesheetFile::VT_IMAGE_NAME, image_name);
  }
  void add_sub_texture(
      ::flatbuffers::Offset<
          ::flatbuffers::Vector<::flatbuffers::Offset<G::Subtexture>>>
          sub_texture) {
    fbb_.AddOffset(SpritesheetFile::VT_SUB_TEXTURE, sub_texture);
  }
  explicit SpritesheetFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpritesheetFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpritesheetFile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpritesheetFile> CreateSpritesheetFile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    ::flatbuffers::Offset<::flatbuffers::String> image_name = 0,
    ::flatbuffers::Offset<
        ::flatbuffers::Vector<::flatbuffers::Offset<G::Subtexture>>>
        sub_texture = 0) {
  SpritesheetFileBuilder builder_(_fbb);
  builder_.add_sub_texture(sub_texture);
  builder_.add_image_name(image_name);
  builder_.add_filename(filename);
  return builder_.Finish();
}

struct SpritesheetFile::Traits {
  using type = SpritesheetFile;
  static auto constexpr Create = CreateSpritesheetFile;
  static constexpr auto name = "SpritesheetFile";
  static constexpr auto fully_qualified_name = "G.SpritesheetFile";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
      "filename", "image_name", "sub_texture"};
  template <size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SpritesheetFile> CreateSpritesheetFileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *filename = nullptr,
    const char *image_name = nullptr,
    const std::vector<::flatbuffers::Offset<G::Subtexture>> *sub_texture =
        nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto image_name__ = image_name ? _fbb.CreateString(image_name) : 0;
  auto sub_texture__ =
      sub_texture ? _fbb.CreateVector<::flatbuffers::Offset<G::Subtexture>>(
                        *sub_texture)
                  : 0;
  return G::CreateSpritesheetFile(_fbb, filename__, image_name__,
                                  sub_texture__);
}

struct ScriptFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScriptFileBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_CONTENTS = 6
  };
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  const ::flatbuffers::Vector<uint8_t> *contents() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENTS);
  }
  template <size_t Index>
  auto get_field() const {
    if constexpr (Index == 0)
      return filename();
    else if constexpr (Index == 1)
      return contents();
    else
      static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyVector(contents()) && verifier.EndTable();
  }
};

struct ScriptFileBuilder {
  typedef ScriptFile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(ScriptFile::VT_FILENAME, filename);
  }
  void add_contents(
      ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> contents) {
    fbb_.AddOffset(ScriptFile::VT_CONTENTS, contents);
  }
  explicit ScriptFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScriptFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScriptFile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScriptFile> CreateScriptFile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> contents = 0) {
  ScriptFileBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_filename(filename);
  return builder_.Finish();
}

struct ScriptFile::Traits {
  using type = ScriptFile;
  static auto constexpr Create = CreateScriptFile;
  static constexpr auto name = "ScriptFile";
  static constexpr auto fully_qualified_name = "G.ScriptFile";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
      "filename", "contents"};
  template <size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ScriptFile> CreateScriptFileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *filename = nullptr,
    const std::vector<uint8_t> *contents = nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto contents__ = contents ? _fbb.CreateVector<uint8_t>(*contents) : 0;
  return G::CreateScriptFile(_fbb, filename__, contents__);
}

struct SoundFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SoundFileBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_TYPE = 6,
    VT_CONTENTS = 8
  };
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  G::SoundType type() const {
    return static_cast<G::SoundType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *contents() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENTS);
  }
  template <size_t Index>
  auto get_field() const {
    if constexpr (Index == 0)
      return filename();
    else if constexpr (Index == 1)
      return type();
    else if constexpr (Index == 2)
      return contents();
    else
      static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyVector(contents()) && verifier.EndTable();
  }
};

struct SoundFileBuilder {
  typedef SoundFile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(SoundFile::VT_FILENAME, filename);
  }
  void add_type(G::SoundType type) {
    fbb_.AddElement<uint8_t>(SoundFile::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_contents(
      ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> contents) {
    fbb_.AddOffset(SoundFile::VT_CONTENTS, contents);
  }
  explicit SoundFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SoundFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SoundFile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SoundFile> CreateSoundFile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    G::SoundType type = G::SoundType::OGG,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> contents = 0) {
  SoundFileBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_filename(filename);
  builder_.add_type(type);
  return builder_.Finish();
}

struct SoundFile::Traits {
  using type = SoundFile;
  static auto constexpr Create = CreateSoundFile;
  static constexpr auto name = "SoundFile";
  static constexpr auto fully_qualified_name = "G.SoundFile";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
      "filename", "type", "contents"};
  template <size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SoundFile> CreateSoundFileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *filename = nullptr,
    G::SoundType type = G::SoundType::OGG,
    const std::vector<uint8_t> *contents = nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto contents__ = contents ? _fbb.CreateVector<uint8_t>(*contents) : 0;
  return G::CreateSoundFile(_fbb, filename__, type, contents__);
}

struct AssetsPack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AssetsPackBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMAGES = 4,
    VT_SPRITE_SHEETS = 6,
    VT_SCRIPTS = 8,
    VT_SOUNDS = 10
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<G::ImageFile>> *images()
      const {
    return GetPointer<
        const ::flatbuffers::Vector<::flatbuffers::Offset<G::ImageFile>> *>(
        VT_IMAGES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<G::SpritesheetFile>>
      *sprite_sheets() const {
    return GetPointer<const ::flatbuffers::Vector<
        ::flatbuffers::Offset<G::SpritesheetFile>> *>(VT_SPRITE_SHEETS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<G::ScriptFile>> *scripts()
      const {
    return GetPointer<
        const ::flatbuffers::Vector<::flatbuffers::Offset<G::ScriptFile>> *>(
        VT_SCRIPTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<G::SoundFile>> *sounds()
      const {
    return GetPointer<
        const ::flatbuffers::Vector<::flatbuffers::Offset<G::SoundFile>> *>(
        VT_SOUNDS);
  }
  template <size_t Index>
  auto get_field() const {
    if constexpr (Index == 0)
      return images();
    else if constexpr (Index == 1)
      return sprite_sheets();
    else if constexpr (Index == 2)
      return scripts();
    else if constexpr (Index == 3)
      return sounds();
    else
      static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_IMAGES) &&
           verifier.VerifyVector(images()) &&
           verifier.VerifyVectorOfTables(images()) &&
           VerifyOffset(verifier, VT_SPRITE_SHEETS) &&
           verifier.VerifyVector(sprite_sheets()) &&
           verifier.VerifyVectorOfTables(sprite_sheets()) &&
           VerifyOffset(verifier, VT_SCRIPTS) &&
           verifier.VerifyVector(scripts()) &&
           verifier.VerifyVectorOfTables(scripts()) &&
           VerifyOffset(verifier, VT_SOUNDS) &&
           verifier.VerifyVector(sounds()) &&
           verifier.VerifyVectorOfTables(sounds()) && verifier.EndTable();
  }
};

struct AssetsPackBuilder {
  typedef AssetsPack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_images(::flatbuffers::Offset<
                  ::flatbuffers::Vector<::flatbuffers::Offset<G::ImageFile>>>
                      images) {
    fbb_.AddOffset(AssetsPack::VT_IMAGES, images);
  }
  void add_sprite_sheets(
      ::flatbuffers::Offset<
          ::flatbuffers::Vector<::flatbuffers::Offset<G::SpritesheetFile>>>
          sprite_sheets) {
    fbb_.AddOffset(AssetsPack::VT_SPRITE_SHEETS, sprite_sheets);
  }
  void add_scripts(::flatbuffers::Offset<
                   ::flatbuffers::Vector<::flatbuffers::Offset<G::ScriptFile>>>
                       scripts) {
    fbb_.AddOffset(AssetsPack::VT_SCRIPTS, scripts);
  }
  void add_sounds(::flatbuffers::Offset<
                  ::flatbuffers::Vector<::flatbuffers::Offset<G::SoundFile>>>
                      sounds) {
    fbb_.AddOffset(AssetsPack::VT_SOUNDS, sounds);
  }
  explicit AssetsPackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AssetsPack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AssetsPack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AssetsPack> CreateAssetsPack(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<
        ::flatbuffers::Vector<::flatbuffers::Offset<G::ImageFile>>>
        images = 0,
    ::flatbuffers::Offset<
        ::flatbuffers::Vector<::flatbuffers::Offset<G::SpritesheetFile>>>
        sprite_sheets = 0,
    ::flatbuffers::Offset<
        ::flatbuffers::Vector<::flatbuffers::Offset<G::ScriptFile>>>
        scripts = 0,
    ::flatbuffers::Offset<
        ::flatbuffers::Vector<::flatbuffers::Offset<G::SoundFile>>>
        sounds = 0) {
  AssetsPackBuilder builder_(_fbb);
  builder_.add_sounds(sounds);
  builder_.add_scripts(scripts);
  builder_.add_sprite_sheets(sprite_sheets);
  builder_.add_images(images);
  return builder_.Finish();
}

struct AssetsPack::Traits {
  using type = AssetsPack;
  static auto constexpr Create = CreateAssetsPack;
  static constexpr auto name = "AssetsPack";
  static constexpr auto fully_qualified_name = "G.AssetsPack";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
      "images", "sprite_sheets", "scripts", "sounds"};
  template <size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<AssetsPack> CreateAssetsPackDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<G::ImageFile>> *images = nullptr,
    const std::vector<::flatbuffers::Offset<G::SpritesheetFile>>
        *sprite_sheets = nullptr,
    const std::vector<::flatbuffers::Offset<G::ScriptFile>> *scripts = nullptr,
    const std::vector<::flatbuffers::Offset<G::SoundFile>> *sounds = nullptr) {
  auto images__ =
      images ? _fbb.CreateVector<::flatbuffers::Offset<G::ImageFile>>(*images)
             : 0;
  auto sprite_sheets__ =
      sprite_sheets
          ? _fbb.CreateVector<::flatbuffers::Offset<G::SpritesheetFile>>(
                *sprite_sheets)
          : 0;
  auto scripts__ =
      scripts
          ? _fbb.CreateVector<::flatbuffers::Offset<G::ScriptFile>>(*scripts)
          : 0;
  auto sounds__ =
      sounds ? _fbb.CreateVector<::flatbuffers::Offset<G::SoundFile>>(*sounds)
             : 0;
  return G::CreateAssetsPack(_fbb, images__, sprite_sheets__, scripts__,
                             sounds__);
}

inline const G::AssetsPack *GetAssetsPack(const void *buf) {
  return ::flatbuffers::GetRoot<G::AssetsPack>(buf);
}

inline const G::AssetsPack *GetSizePrefixedAssetsPack(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<G::AssetsPack>(buf);
}

inline bool VerifyAssetsPackBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<G::AssetsPack>(nullptr);
}

inline bool VerifySizePrefixedAssetsPackBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<G::AssetsPack>(nullptr);
}

inline void FinishAssetsPackBuffer(::flatbuffers::FlatBufferBuilder &fbb,
                                   ::flatbuffers::Offset<G::AssetsPack> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAssetsPackBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<G::AssetsPack> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace G

#endif  // FLATBUFFERS_GENERATED_ASSETS_G_H_
